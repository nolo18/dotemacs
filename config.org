#+title: Configuración de Emacs
#+updated: <2021-09-17 20:51:18>
#+author: M. Márquez
#+email: nolo18@khelent.xyz
#+todo: TODO(t!) INVESTIGANDO(i!) ENCURSO(e) |CANCELADO(c@) HECHO(h!)
#+startup: indent content

* Descripción.
Después de muchos años usando [[https://www.gnu.org/software/emacs/][Emacs]], tanto con configuraciones muy básicas hechas por mi como utilizando otras prestablecidas, [[https://github.com/hlissner/doom-emacs][doom-emacs]] por ejemplo, en ninguno de los casos me he encontrado realmente cómodo.

En el primero de los casos, configuracines muy básicas hechas por mi, bien por falta de tiempo o por falta de ganas, estas configuraciones, ni cubrían todas mis necesidades, ni utilizaban apenas todo el potencial que tiene este editor.

En el segundo de los casos, supongo que por ser configuraciones muy generales, o tal vez por ser hechas por otras personas, tampoco se adaptaban muy bien a mi modo de trabajo. Además, últimamente me había dado cuenta que pasaba más tiempo intentando averiguar cómo deshabilitar cosas en =doom-emacs= porque no me gustaban que disfrutando del entorno. Realmente =doom-emacs= es una muy buena configuración, pero añade una capa de personalización tan grande al editor que lo hace incompatible conmigo.

Por todo ello nace este proyecto, como un intento serio de adaptar =Emacs= realmente a mis necesidades y gustos, y de paso aprender cosas interesantes y disfrutar en el proceso.

* Opciones por defecto.

Seamos honestos, la configuración por defecto de =Emacs= es, desde mi punto de vista, bastante anticuada. Sige aferrada a convicciones informática de los ochenta. Hoy en día han cambiado mucho las cosas, y si bien entonces eran muy prácticas, hoy en día, más que prácticas, pueden resultar incluso molestas, en el caso de algunas de ellas...

Arreglemos eso.

*Nota:* Para no tener problemas más adelante en el proceso de configuración, es muy importante dejar claro que queremos utilizar en todo el fichero =lexical-binding=. ¿Por qué?, porque quiero dejar bien acotado y fijado el ámbito de las variables. (No entiendo cómo es algo que no viene establecido por defecto).
Como bien explica en la documentación, esta variable es local para cada fichero y debe explícitamente ser fijada en la primera línea del archivo.

#+begin_src emacs-lisp
  (setq lexical-binding t)
#+end_src

Los valores por defecto de las siguientes opciones me resultan bastante intrusivos, así como incómodos, cabiémoslos por otros más adecuados.

#+begin_src emacs-lisp
  (setq
   ;; Omitir la pantalla de vienvenida
   inhibit-startup-screen t
   ;; No necesito que me recuerden para que sirve el *scratch* buffer
   initial-scratch-message nil
   ;; Dos espacios despues del punto y final de una frase es una falta
   ;; de ortografía.
   sentence-end-double-space nil
   ;; No necesito avisos visuales o sonoros de ningún tipo.
   ring-bell-function 'ignore
   ;; Cuando deselecciono algo quiero desactivar la marca.
   mark-even-if-inactive nil
   ;; Las búsquedas deben diferenciar mayúsculas y minúsculas por defecto.
   case-fold-search nil
   ;; Ir a la ventana de ayuda cuando la abro
   help-window-select t
   ;; No quiero ningún comando deshabilitado. Correré el riesgo!!!
   disabled-command-function nil
   ;; Dejar un poco de contexto al hacer scroll en la ventana.
   scroll-margin 5
   ;; No mostrar el cursor en las ventanas no seleccinadas
   cursor-in-non-selected-windows nil
   )
#+end_src

El principio de ahorro es importante.

#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

El cursor mejor sin parpadeo

#+begin_src emacs-lisp
  (blink-cursor-mode -1)
#+end_src

Es estupendo que =Emacs= soporte gran variedad de codificaciones de caracteres, pero UTF-8 debe ser siempre, siempre el preferido.

#+begin_src emacs-lisp
  (set-charset-priority 'unicode)
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (setq default-process-coding-system '(utf-8-unix . utf-8-unix))
#+end_src

=Emacs= tiende a llenar mi sistema de archivos con copias de seguridad, archivos temporales de autosalvado y similares, ya que trabaja bajo la premisa de que varios usuarios pueden estar modificando el mismo fichero a la vez. No es mi caso, así que es mejor desactivar todas esas copias de respaldo... Correré el riesgo!!!!

#+begin_src emacs-lisp
  (setq
   make-backup-files nil
   auto-save-default nil
   create-lockfiles nil)
#+end_src

* Gestor de paquetes

Después de probar varias opciones, [[https://github.com/raxod502/straight.el][straight.el]] junto con [[https://github.com/jwiegley/use-package][use-package]] me parece la forma más adecuada de administrar los paquetes necesarios para esta configuración.
Algunas de las ventajas:
+ straight.el instala los paquetes directamente desde los repositorios, con lo que se obtienen versiones más recientes.
+ Puedo decidir el directorio en el que straight.el instalará para después cargar los modulos.
+ straight.el se integra perfectamente con use-package.
+ use-package es un sistema de =macros= que facilita muchísimo las tareas de configuración de los distintos paquetes instalados.

*Inicializar y configurar straight.el*

No mostrar ningún reporte del proceso en el buffer =*straight-process*=

#+begin_src emacs-lisp
  (setq straight-process-buffer " ")
#+end_src

Instalar straight.el si no está instalado e inicializarlo.

#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

Instalar =use-package= y configurarlo para integrarlo con straight

#+begin_src emacs-lisp
  (straight-use-package 'use-package)

  (setq straight-use-package-by-default t)
#+end_src

* Apariencia
Quiero que mi editor tenga un aspecto agradable y limpio.

** Fuente por defecto

La idea de esta configuración es que sea portable. Por eso, no voy a fijar una sola fuente como predeterminada, sino una colección de ellas por orden de preferencia y fijar la primera correspondencia instalada en el sistema. Si no hay ninguna de ellas, dejar /DejaVu/ que es la que viene por defecto y que no está del todo mal.

#+begin_src emacs-lisp
  (cond
   ((x-family-fonts "SauceCodePro Nerd Font Mono")
    (set-frame-font "SauceCodePro Nerd Font Mono"))
   )
#+end_src

** modus-themes
[[https://protesilaos.com/modus-themes/][home]]
Después de probar una gran cantidad de esquemas de color, tanto claros, como oscuros, no he visto nada mejor que estos dos temas complementarios.
Son altamente configurables, y tanto el tema claro como el oscuro son de los más cómodos de leer que he visto.

#+begin_src emacs-lisp
  (use-package modus-themes
    :init
    (setq
     modus-themes-italic-constructs t	         ;Cursivas en comentarios y demás
     modus-themes-syntax '(faint alt-syntax)       ;Coloreado de sintaxis más llamativo
     modus-themes-links '(faint neutral-underline) ;Links subrayados
     modus-themes-prompts '(bold)		 ;Apariencia del minibuffer
     modus-themes-mode-line nil		 ;Apariencia del modeline
     modus-themes-completions 'opinionated		 ;Apariencia de los pupups de autocompletado
     modus-themes-hl-line nil			 ;Tendré que ir probando
     modus-themes-paren-match '(bold)		 ;En negrita el complementario.
     modus-themes-region '(bg-only)		 ;Aspecto de las selecciones
     modus-themes-diffs 'desaturated		 ;Aspecto de los diffs en ficheros.
     modus-themes-org-blocks 'tinted-background	 ;Fondo de los bloques de código
     modus-themes-headings nil	 ;Coloreado de los encabezados
     modus-themes-scale-headings t		 ;Hacer los encabezados más grandes.
     )                                             ;Se puede personalizar el tamaño (ver doc)
    (modus-themes-load-themes)
    :config
    (modus-themes-load-operandi))
#+end_src

* Útiles
Colección de paquetes de utilidad general que facilitan mucho la vida.

** diminish
[[https://github.com/emacsmirror/diminish][home]]
Con el uso de muchos modos menores, el apartado del modeline destinado a los modos menores, se va llenando de numerosos indicadores, de modos menores de los que realmente no necesito información alguna. Mejor limpiarlos.

Diminish se integra muy bien con =use-package=, así que en el caso de los paquetes instalados por mi, puedo quitarlos desde use-package con la directiva =:diminish=.

Para el resto, puedo hacerlo aquí directamente.

#+begin_src emacs-lisp
  (use-package diminish
    :init
    (diminish 'auto-revert-mode)
    (diminish 'eldoc-mode))
#+end_src

** magit
[[https://magit.vc/][home]]
*magit* es una de las mejores, y más productivas herramientas que he visto para trabajar con repositorios git.

#+begin_src emacs-lisp
  (use-package magit)
#+end_src

** Projectile
[[https://docs.projectile.mx/projectile/index.html][docs]]
Una librería muy interesante para manejar proyectos en Emacs.

#+begin_src emacs-lisp
  (use-package projectile
    :init
    (setq
     ;; Ordena los ficheros y los buffers anteponiendo los
     ;; utilizados más recientemente o los ficheros abiertos
     ;; más recientemente
     projectile-sort-order 'recentf
     ;; TODO: "Caching" ficheros
     ;; Resulta bueno para proyectos con mucos ficheros, a ver
     ;; cómo funciona de modo general.
     projectile-enable-caching t
     ;; Abrir la carpeta de proyecto cuando cambio a un proyecto
     ;; nuevo
     projectile-switch-project-action 'projectile-dired
     ;; Indicador a mostrar en el "modeline"
     projectile-mode-line-function '(lambda () (format " [%s]" (projectile-project-name)))
     )
    (projectile-mode 1)
    :bind (:map projectile-mode-map
                ("C-c p" . projectile-command-map))
    )
#+end_src

** sudo-edit
[[https://github.com/nflath/sudo-edit][home]] (muy parca en detalles)
Es muy interesante tener la opción de editar archivos como superusuario manteniendo toda mi configuración.

#+begin_src emacs-lisp
  (use-package sudo-edit)
#+end_src

** vertico
[[https://github.com/minad/vertico][home]]
Me gusta seleccionar archivos, buffers y demás de forma interactiva, y según parece este nuevo complemento es de lo más liviano que conozco.
/ido-mode/ -> Se me queda corto
/ivy y amigos/ -> No necesito tantas funciones.

Aunque para afinar la configuración =vertico= requiere ciertos plugins, sigue siendo más liviano, y según proclama se integra mucho mejor con Emacs sin tener que hacer muchas configuraciones adicionales.

#+begin_src emacs-lisp
  (use-package vertico
    :config
    (setq vertico-cycle t)
    :init
    (vertico-mode))
#+end_src

El paquete [[https://github.com/oantolin/orderless][orderless]] ofrece soporte para completados parciales (escribiendo partes de palabras) y también la utilización de comodines para, por ejemplo abrir varios ficheros a la vez. Es un estilo a /fzf/ para vim.

#+begin_src emacs-lisp
  (use-package orderless
    :init
    (setq completion-styles '(orderless)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))
#+end_src

El paquete [[https://github.com/minad/marginalia][marginalia]] inserta interesantes anotaciones a las opciones de vertico.

#+begin_src emacs-lisp
  (use-package marginalia
    :init
    (marginalia-mode 1))
#+end_src

** which-key
[[https://github.com/justbur/emacs-which-key][home]]
Después de tantos años usando =Emacs=, soy incapaz de recordar mas del 1% de los atajos de teclado. =which-key= es el mejor compañero para ayudarme a recordarlos, así como para aprender algunos nuevos.

#+begin_src emacs-lisp
  (use-package which-key
    :diminish
    :config
    (which-key-mode 1))
#+end_src

* Org-mode
[[https://orgmode.org/][Org-mode]]

Definitivamente es la razón por la que uno se enamora de Emacs.
Es como una navaja suiza.
Cuenta con tantas opciones de configuración que es casi mejor dedicarle un apartado diferente.

** Opciones por defecto

Org-mode cuenta con un montón de variables que configurar... (Seguramente me dejo alguna atrás)

#+begin_src emacs-lisp
  (setq
   ;; Ocultar los caracteres para indicar negrita, cursiva y demás
   org-hide-emphasis-markers t
   ;; Visitar el enlace al pulsar ENTER sobre ellos
   org-return-follows-link t
   ;; Ir directamente al buffer de edición de un bloque de código
   ;; si ya está abierto
   org-src-ask-before-returning-to-edit-buffer t
   ;; No quiero ningún encabezado para las notas al pie
   org-footnote-section ""
   ;; Cambiar los tres puntos por algo más atractivo
   org-ellipsis " ↴"
   ;; Todas las notas de estado se insertan en "drawers"
   org-log-into-drawer t
   ;; No quiero que al editar un bloque de código me reorganice
   ;; todas las ventanas abiertas para dejarme dos
   org-src-window-setup 'current-window
   ;; alinea las etiquetas en la columna 80
   org-tags-column -80
   )
#+end_src

Aunque con los asteriscos queda bien, prefiero mostrar otros caracteres utf-8 más interesantes y agradables a la vista.
[[https://github.com/sabof/org-bullets][org-bullets]] sirve para eso precisamente.

#+begin_src emacs-lisp
  (use-package org-bullets
    :hook (org-mode . (lambda () (org-bullets-mode 1))))
#+end_src

Quiero usar visual line mode siempre en org-mode (al menos de momento).

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook #'visual-line-mode)
#+end_src

* Apátridas

Este apartado contiene las configuraciones para las que todavía no he decidido un apartado específico dentro de este fichero.

_Información Personal:_ Esta información es útil a la hora de utilizar plantillas y otras opciones del editor.

#+begin_src emacs-lisp
  (setq user-full-name "M. Márquez"
        user-mail-address "nolo18@khelnet.xyz")
#+end_src

* En pruebas

Todas las configuraciones contenidas en este apartado están en periodo de pruebas, es decir, que todavía no son definitivas, o no están bien definidas todavía.

** Todas las interacciones en el minibuffer.
Esta configuración hace que cualquier interacción, aunque proceda de una acción del ratón, se gestione en el minibuffer. En un primer momento parece interesante, puesto que mi idea es utilizar el ratón lo menos posible. Pero puede que sea poco útil en el caso de =flyspell=. Esto tengo que mirarlo detenidamente.

#+begin_src emacs-lisp
  (setq use-dialog-box nil)
#+end_src

** C-k borra la linea completa

Esta es la misma funcionalidad que en vim/nvim. Pero últimamente me he acostumbrado a borrar desde la posición actual hasta el final y no se si quiero cambiar eso. Lo voy a probar un tiempo en cualquier caso. (de momento va perdiendo puntos).

#+begin_src emacs-lisp
  (setq kill-whole-line t)
#+end_src

** Ubicación de /custom_file/
=Emacs= almacena cualquier configuración que se realice a través de su sistema de configuración visual o utilizando la función =custom-set-variable= en el archivo de configuración inicial, o si se define este fichero en la variable =custom-file=. De igual modo, se almacena cierta información de seguridad y fiabilidad de algunos esquemas de color y demás.

Yo quiero mi archivo de configuración limpio de intrusiones de cualquier tipo, así que prefiero especificar el archivo donde guardar estas configuraciones automáticas. (Aunque no creo que hayan muchas).

*Nota:* La ubicación de este fichero aún no es definitiva.

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name ".custom.el" user-emacs-directory))
#+end_src

** modus-themes
Ya está hecha la primera configuración, a ver cómo va funcionando.
Después de haber estado un tiempo probando esta configuración encuentro demasiado fuertes los colores de los encabezados tal y como están ahora configurados los temas... Supongo que habrá que echarles un vistazo a ver si puedo suavizar esta sensación un poco.

** Espacios en blanco al final
El tratamiento de los espacios en blanco al final de las lineas está más que claro... Eliminarlos sin piedad!!!!... Además de añadir una linea en blanco al final de los archivos que está siendo la regla ultimamente. Hagamoslo de forma automática.

#+begin_src emacs-lisp
  (add-hook 'before-save-hook #'delete-trailing-whitespace)
  (setq require-final-newline t)
#+end_src

** INVESTIGANDO Insertar automáticamente la fecha de modificación para los ficheros org
:LOGBOOK:
- State "INVESTIGANDO" from              [2021-09-17 vie 19:14]
:END:

Es interesante poder añadir automáticamente la fecha de última modificación de los ficheros. Emacs cuenta con esta funcionalidad con la función =time-stamp=. Ver [[https://www.emacswiki.org/emacs/TimeStamp][EmacsWiki]] para más información.

La idea es definir un patrón de búsqueda detrás del cual, Emacs agregará la fecha cada vez que el fichero se salve. Claro está que para ello hay que añadir a =before-save-hook= la función =time-stamp=.

*Nota:* Como bien dicen no es muy recomendable definir este patrón globalmente!!.

Por ello Emacs ofrece muchas opciones de configuración a distintos niveles.
- /Directorio/: Es una opción interesante que permite definir este patrón para todos los archivos en un directorio concreto. (Muy interesante para definirlo para todo un proyecto)
- /Archivo/: Para ello se inserta un comentario con la definición del patrón (al estilo de "lexical-bindings" en los ficheros emacs-lisp.
- /Tipo de archivo/: Para ello se solo hay que definir esta variable como local en una función /lambda/ y agregarla al hook correspondiente.

Mi interés es principalmente para el fichero de configuración, por lo que a nivel de directorio sería muy satisfactorio. No obstante, esta misma funcionalidad puede interesarme para todos los ficheros org. Por lo que voy a probar a implementar esta funcionalidad insertando la fecha como una propiedad global del documento, y definiendo el patrón a nivel de /tipo de archivo/.

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook (lambda ()
                                  (set (make-local-variable 'time-stamp-pattern)
                                       "8/updated:[ \t]+\\\\?[\"<]+%:y-%02m-%02d %02H:%02M:%02S\\\\?[\">]")))

  (add-hook 'before-save-hook #'time-stamp)

#+end_src

** INVESTIGANDO Modos de programación
:LOGBOOK:
- State "INVESTIGANDO" from              [2021-09-17 vie 19:52]
:END:
Me interesa activar de modo automático para todos los modos de programación algunas funcionalidades.
- números de lienas
- indicador de lineas largas
- etc

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook #'(lambda ()
                                (display-line-numbers-mode)
                                ;; Show indicator at column 80
                                (setq-local fill-column 80)
                                (display-fill-column-indicator-mode)))
#+end_src

*** Específico para algunos modos.
**** C
Tabulación en C. Usar tabulador de cuatro espacios para el código y utilizar el estilo "linux"

#+begin_src emacs-lisp
  (setq-default c-default-style "linux"
                c-basic-offset 4)

  (add-hook 'c-mode-hook #'(lambda ()
                             (setq-local indent-tabs-mode t)))
#+end_src



** INVESTIGANDO Tabuladores
:LOGBOOK:
- State "INVESTIGANDO" from "TODO"       [2021-09-17 vie 20:49]
:END:
Todavía no tengo claro si quiero utilizar tabuladores o espacios para indentar mis ficheros. Es algo que tengo que estudiar cuidadosamente.

En principio voy a utilizar cuatro espacios para indentar de modo general... Cambiaré eso para algunos modos (Como C que usará tabuladores de 4 espacios para indentar).

#+begin_src emacs-lisp
  (setq-default tab-width 4
            indent-tabs-mode nil)
#+end_src

* Tareas pendientes [0/21]

Tengo mala cabeza, para qué lo vamos a negar. Necesito llevar un registro de cosas que quiero hacer, si no, las olvido rápidamente.

** TODO Straight.el

[[Gestor de paquetes]]

*Nota:* ver [[variables locales.]] Aquí sería interesante tener definida ya una variable local para mi directorio "$HOME/.local/share/emacs". Creo que este es el directorio adecuado. /nvim lo usa/.

- En principio no hay manera de que =straight.el= instale los paquetes en una ruta fuera de =user-emacs-directory=.

** TODO Echar un vistazo a paquetes que son recomendados por muchos.
  - [ ] undo-tree
  - [ ] all-the-icons; all-the-icons-dired
  - [ ] diminish (seguramente si) No quiero el "modeline" lleno de
  información innecesaria.
  - [ ] doom-themes; doom-modeline -> Quiero algo más limpio. Para
  eso instalo doom directamente.
  - [ ] tree-sitter Parece ser que hace bastante bien su trabajo
  en cuanto al resaltado de sintaxis.
  - [ ] centaru-tabs -> No creo que quiera pestañas pero echaré
  un vistazo.
  - [-] sudo-edit -> Esto si es interesante si quiero editar ficheros
  de configuración sin tener que hacerlo en consola.
  - [-] which-key -> Definitivamente si.
  - [ ] bufler -> ¿?
  - [ ] ace-window -> Definitivamente si. Después de haber estado
  un tiempo utilizando "other-window" it is not a great thig. Mirar
  esta configuración.
     (use-package ace-window
       :config
       ;; Show the window designators in the modeline.
       (ace-window-display-mode)

        ;; Make the number indicators a little larger. I'm getting old.
       (set-face-attribute 'aw-leading-char-face nil :height 2.0 :background "black")

       (defun my-ace-window (args)
         "As ace-window, but hiding the cursor while the action is active."
         (interactive "P")
         (cl-letf
             ((cursor-type nil)
              (cursor-in-non-selected-window nil))
           (ace-window nil)))


       :bind (("C-," . my-ace-window))
       :custom
       (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l) "Designate windows by home row keys, not numbers.")
       (aw-background nil))

  - [ ] org-bullets -> ¿Por qué no?
  - [ ] magit -> Por supuestísimo.... (ejemplo)
     (use-package magit
     	   :diminish magit-auto-revert-mode
     	   :diminish auto-revert-mode
     	   :bind (("C-c g" . #'magit-status))
     	   :custom
     	   (magit-repository-directories '(("~/src" . 1)))
     	   :config
     	   (add-to-list 'magit-no-confirm 'stage-all-changes))

   - [ ] Projectile -> Claro que si.. Mirar documentación por si hay
   algo realmente interesante.
   - [ ] Ivi, counsel, swiper -> Creo que vertico es más eficiente.
   - [ ] flycheck -> Por ahora no.
   - [ ] deadgrep -> ¿?
   - [ ] visual-regexp
   - [ ] company -> Seguramente si pero solo para elisp por ahora.
   - [ ] lsp -> Por ahora no me voy a meter en eso... tengo doom-emacs
   perfectamente configurado para eso.
   - [ ] vterm -> Todo el mundo habla muy bien de ella, habrá que
   echar un vistazo.
   - [ ] yasnippet -> Seguramente si, pero por ahora no lo necesito.
   - [ ] neotree -> Casi mejor treemacs.

** INVESTIGANDO Configurar which-key

[[which-key]]

Existe una función muy interesante que te muestra solo los atajos de teclado del "major-mode" correspondiente al actual buffer. Es muy interesante y mucho más práctico que =C-h m=. Quizá sea conveniente asignarle un atajo de teclado.

** INVESTIGANDO Configurar Magit

[[magit]]

No se si voy a necesitar alguna configuración adicional, pero no está de más echar un vistazo.

** ENCURSO Configurar =todo keywords= locales para este fichero.
Esto pinta que va a ser un fichero conplejo, y aprovechando la potencia de /org-mode/ quiero tener controlado todo lo que voy haciendo. Por ello quiero tener distintos estados para las tareas en este fichero, que me ayuden a encontrar facilmente lo que estoy buscando. Por ejemplo, no son los mismos estados para las tareas pendientes (TODO-INVESTIGANDO-ENCURSO-HECHA-CANCELADA) que para las configuraciones en prueba (PROBANDO-REFINANDO-ADMITIDA), o algo, asi. Que tengan un log con las fechas de los cambios es un plus.

** TODO Etiquetas
El uso de etiquetas es muy útil a la hora de buscar cosas, pero definir bien las etiquetas va a ser algo engorroso.

** TODO Echar un vistazo a ERC
Puede ser interesante tener el irc integrado aquí.

** TODO /user-emacs-directory/ limpio
Quiero que mi directorio de configuración esté limpio. En otros tiempos era muy buena idea tener todo lo relativo a emacs en el directorio de configuración, pero hoy en día con =xdesktop= todo ha cambiado, y existen un montón de directorios en el sistema mucho más apropiados para poner según que cosas. Estos directorios se guardan en variables de entorno, como /XDG_CONFIG_HOME, XDG_DATA_DIRS/, etc... Es ahí donde quiero poner todos los ficheros que genere esta configuración, así como los paquetes que instale.

** TODO Emojis
Una manera de configurar los emojis facilmente sería algo así.

#+begin_src emacs-lisp :tangle no
  (if ( version< "27.0" emacs-version )
      (set-fontset-font "fontset-default" 'unicode "Apple Color Emoji" nil 'prepend)
    (warn "This Emacs version is too old to properly support emoji."))
#+end_src

** TODO Desactivar atajos de teclados
Hay un montón de atajos de teclados que, en mi humilde opinión, son del todo inútiles, al menos para mí, y que pueden ser pulsados de modo accidental. Mejor desactivarlos.

** TODO variables locales.
No tengo todavía claro si voy a definir algunas variables locales en mi configuración, seguramente si. Según parece pueden dar algún que otro problema de incómodos avisos de seguridad. La manera de desactivar esos avisos es habilitando las variables locales.

#+begin_src emacs-lisp :tangle no
  (setq enable-local-variables :all)
#+end_src

** ENCURSO Seleccionar fuente por defecto.
Creo que lo mejor es hacerlo con un =cond= y comprobar por orden de preferencia las fuentes instaladas en el equipo (así se hace más portable la configuración) y utilizar la primera coincidencia. Si no hay ninguna no cambiarla y dejar /DejaVu/ que es la que trae por defecto y tal vez emitir alguna alerta o algo...
En principio está puesta /SauceCodePro Nerd Font Mono/ como fuente por defecto y no hay más opciones en el cond. Habrá que ir probando.

** TODO Resaltar parejas de paréntesis y demás...
Lo mismo instalo smartparens y mato unos cuantos pájaros de un tiro.
- Se autoinserta el cierre correspondiente
- Se resalta el par asociado
- Obtengo la funcionalidad de paredit con =spartparens-strict-mode=

#+begin_src emacs-lisp
  (show-paren-mode 1)
#+end_src

** INVESTIGANDO fill-column y amigos.
:LOGBOOK:
- State "INVESTIGANDO" from "TODO"       [2021-09-17 vie 19:51]
:END:
Para editar texto plano puede ser muy interesante la función =fill-paragraph= (M-q), que justifica el texto a un ancho determinado atendiendo al valor de la variable =fill-column=. Puede ser muy interesante fijar de modo local según el tipo de fichero esta variable y utilizar esta funcionalidad interesante, así como =display-fill-column-indicator-mode=.

Quizá me interese hacer locales para todos los modos de programación la variable *fill-column*. En este ámbito, la usaría simplemente para activar el indicador de línea demasiado larga.

** TODO Fácil acceso al archivo de configuración.
Sería muy interesante fijar un atajo fácil de teclado para abrir el archivo de configuración, y crear la función correspondiente.
*Nota:* Aquí sería interesante el tener ese archivo fijado a una variable global definida con =defvar=.
Otra opción sería instalar una pantalla de inicio que facilite estas tareas, aunque no creo que quiera instalar esa cosa por ahora.

** TODO minibuffer
Hay muchas configuraciones del minibuffer que ni conocía. Habrá que echar un vistazo a eso. algunas de ellas son... =enable-recursive-minibuffers=, =minibuffer-depth-indicate-mode=, etc...

** TODO Algunas funciones interesantes.
Buscando en las configuraciones de otras personas, he encontrado algunas funciones muy interesantes que puedo utilizar en mi vida diaria...

*** kill-this-buffer
Como suena, poder eliminar el buffer actual, sin más preguntas.

#+begin_src emacs-lisp :tangle no
  (defun kill-this-buffer ()
    "Kill the current buffer."
    (interactive)
    (kill-buffer nil)
    )
  (bind-key "C-x k" #'kill-this-buffer)
  (bind-key "C-x K" #'kill-buffer)
#+end_src

*** kill-all-buffers
Esto podría ser interesante, para cuando empiece a trabajar con =Emacs= en modo cliente... Así podría cambiar de tarea facilmente... Aunque la función anterior me parece más interesante.

#+begin_src emacs-lisp :tangle no
  (defun kill-all-buffers ()
    "Close all buffers."
    (interactive)
    ;; (maybe-unset-buffer-modified)
    (save-some-buffers)
    (let ((kill-buffer-query-functions '()))
      (mapc 'kill-buffer (buffer-list))))
#+end_src

*** Cambiar al buffer =*scratch*= facilmente.
Puede ser interesante acceder a este buffer facilmente... Habrá que ver si lo necesito muy a menudo.

#+begin_src emacs-lisp :tangle no
  (defun switch-to-scratch-buffer ()
    "Switch to the current session's scratch buffer."
    (interactive)
    (switch-to-buffer "*scratch*"))

  (bind-key "C-c a s" #'switch-to-scratch-buffer)
#+end_src

** ENCURSO org-mode
Definitivamente me pasaré toda la vida y no le sacaré ni la mitad de partido a org-mode... Pero por algo hay que empezar. He visto algunas opciones muy interesantes a las que habrá que prestar mucha más atención...
- Seguro que hay por ahí alguna opción para decidir si exportar los comentarios de los bloques de código o no.
- etc...

Creo que lo más sensato es tener un apartado solo para configurar orgmode.

Castellanizar calendarios?

Configurar =org-directory= para un rapido acceso a mis archivos de agenda y demás.

Configurar los bloques de código que puedo ejecutar.

** TODO diminish auto-revert-mode
No sé muy bien por qué pero sigue apareciendo...

** TODO provide?
Seria conveniente poner este último bloque de código.

#+begin_src emacs-lisp :tangle no
  (provide 'config.el)
#+end_src
